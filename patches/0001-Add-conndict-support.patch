From 7a285e66aff7979233753298cdf68770833a2314 Mon Sep 17 00:00:00 2001
From: Brett Mastbergen <bmastbergen@untangle.com>
Date: Fri, 11 May 2018 10:45:00 -0400
Subject: [PATCH] Add conndict support

---
 include/netfilter.mk                               |    6 +
 package/kernel/linux/modules/netfilter.mk          |   16 +
 package/network/utils/iptables/Makefile            |   16 +
 .../iptables/patches/900-iptables-conndict.patch   |  185 +++
 .../backport-4.14/369-netfilter-Add-conndict.patch | 1540 ++++++++++++++++++++
 5 files changed, 1763 insertions(+)
 create mode 100644 package/network/utils/iptables/patches/900-iptables-conndict.patch
 create mode 100644 target/linux/generic/backport-4.14/369-netfilter-Add-conndict.patch

diff --git a/include/netfilter.mk b/include/netfilter.mk
index 5d532cea5b..5e55868f1c 100644
--- a/include/netfilter.mk
+++ b/include/netfilter.mk
@@ -250,6 +250,11 @@ $(eval $(call nf_add,IPT_NFLOG,CONFIG_NETFILTER_XT_TARGET_NFLOG, $(P_XT)xt_NFLOG
 $(eval $(call nf_add,IPT_NFQUEUE,CONFIG_NETFILTER_XT_TARGET_NFQUEUE, $(P_XT)xt_NFQUEUE))
 
 
+# conndict
+
+$(eval $(call nf_add,IPT_CONNDICT,CONFIG_NETFILTER_XT_MATCH_CONNDICT, $(P_XT)xt_conndict))
+
+
 # debugging
 
 $(eval $(call nf_add,IPT_DEBUG,CONFIG_NETFILTER_XT_TARGET_TRACE, $(P_XT)xt_TRACE))
@@ -347,6 +352,7 @@ $(eval $(if $(NF_KMOD),$(call nf_add,NFT_CORE,CONFIG_NF_TABLES_IPV6, $(P_V6)nf_t
 $(eval $(if $(NF_KMOD),$(call nf_add,NFT_CORE,CONFIG_NFT_CHAIN_ROUTE_IPV6, $(P_V6)nft_chain_route_ipv6),))
 $(eval $(if $(NF_KMOD),$(call nf_add,NFT_CORE,CONFIG_NFT_REDIR, $(P_XT)nft_redir, ge 3.19.0),))
 $(eval $(if $(NF_KMOD),$(call nf_add,NFT_CORE,CONFIG_NFT_QUOTA, $(P_XT)nft_quota, ge 4.9.0),))
+$(eval $(if $(NF_KMOD),$(call nf_add,NFT_CORE,CONFIG_NFT_DICT, $(P_XT)nft_dict),))
 
 $(eval $(if $(NF_KMOD),$(call nf_add,NFT_ARP,CONFIG_NF_TABLES_ARP, $(P_V4)nf_tables_arp),))
 
diff --git a/package/kernel/linux/modules/netfilter.mk b/package/kernel/linux/modules/netfilter.mk
index 51f3544ed6..31260dbc32 100644
--- a/package/kernel/linux/modules/netfilter.mk
+++ b/package/kernel/linux/modules/netfilter.mk
@@ -518,6 +518,22 @@ endef
 $(eval $(call KernelPackage,ipt-nfqueue))
 
 
+define KernelPackage/ipt-conndict
+  TITLE:=Module for matching conndict entries
+  DEPENDS:=+kmod-ipt-conntrack
+  KCONFIG:=CONFIG_NETFILTER_XT_MATCH_CONNDICT
+  FILES:=$(foreach mod,$(IPT_CONNDICT-m),$(LINUX_DIR)/net/$(mod).ko)
+  AUTOLOAD:=$(call AutoProbe,$(notdir $(IPT_CONNDICT-m)))
+  $(call AddDepends/ipt)
+endef
+
+define KernelPackage/ipt-conndit/description
+ Netfilter module for matching conndict entries
+endef
+
+$(eval $(call KernelPackage,ipt-conndict))
+
+
 define KernelPackage/ipt-debug
   TITLE:=Module for debugging/development
   KCONFIG:=$(KCONFIG_IPT_DEBUG)
diff --git a/package/network/utils/iptables/Makefile b/package/network/utils/iptables/Makefile
index d70dc11d45..5268c6517b 100644
--- a/package/network/utils/iptables/Makefile
+++ b/package/network/utils/iptables/Makefile
@@ -258,6 +258,21 @@ define Package/iptables-mod-nfqueue/description
 
 endef
 
+
+define Package/iptables-mod-conndict
+$(call Package/iptables/Module, +kmod-ipt-conndict)
+  TITLE:=Netfilter conndict match
+endef
+
+define Package/iptables-mod-conndict/description
+ iptables extension for matching conndict entries
+
+ Includes:
+  - libxt_conndict
+
+endef
+
+
 define Package/iptables-mod-hashlimit
 $(call Package/iptables/Module, +kmod-ipt-hashlimit)
   TITLE:=hashlimit matching
@@ -635,6 +650,7 @@ $(eval $(call BuildPlugin,iptables-mod-u32,$(IPT_U32-m)))
 $(eval $(call BuildPlugin,iptables-mod-nflog,$(IPT_NFLOG-m)))
 $(eval $(call BuildPlugin,iptables-mod-trace,$(IPT_DEBUG-m)))
 $(eval $(call BuildPlugin,iptables-mod-nfqueue,$(IPT_NFQUEUE-m)))
+$(eval $(call BuildPlugin,iptables-mod-conndict,$(IPT_CONNDICT-m)))
 $(eval $(call BuildPlugin,iptables-mod-checksum,$(IPT_CHECKSUM-m)))
 $(eval $(call BuildPackage,ip6tables))
 $(eval $(call BuildPlugin,ip6tables-extra,$(IPT_IPV6_EXTRA-m)))
diff --git a/package/network/utils/iptables/patches/900-iptables-conndict.patch b/package/network/utils/iptables/patches/900-iptables-conndict.patch
new file mode 100644
index 0000000000..3f850b75a7
--- /dev/null
+++ b/package/network/utils/iptables/patches/900-iptables-conndict.patch
@@ -0,0 +1,185 @@
+From 319e6f4e36647d0dd53b7c28cd1d49b48f1d28c4 Mon Sep 17 00:00:00 2001
+From: Brett Mastbergen <bmastbergen@untangle.com>
+Date: Mon, 12 Feb 2018 13:45:15 -0500
+Subject: [PATCH] iptables conndict
+
+---
+ extensions/libxt_conndict.c   | 144 ++++++++++++++++++++++++++++++++++++++++++
+ extensions/libxt_conndict.man |  14 ++++
+ 2 files changed, 158 insertions(+)
+ create mode 100644 extensions/libxt_conndict.c
+ create mode 100644 extensions/libxt_conndict.man
+
+diff --git a/extensions/libxt_conndict.c b/extensions/libxt_conndict.c
+new file mode 100644
+index 00000000..b78acfaf
+--- /dev/null
++++ b/extensions/libxt_conndict.c
+@@ -0,0 +1,144 @@
++/* Shared library add-on to iptables to add string matching support. 
++ * 
++ * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
++ *
++ * 2005-08-05 Pablo Neira Ayuso <pablo@eurodev.net>
++ * 	- reimplemented to use new string matching iptables match
++ * 	- add functionality to match packets by using window offsets
++ * 	- add functionality to select the string matching algorithm
++ *
++ * ChangeLog
++ *     29.12.2003: Michael Rash <mbr@cipherdyne.org>
++ *             Fixed iptables save/restore for ascii strings
++ *             that contain space chars, and hex strings that
++ *             contain embedded NULL chars.  Updated to print
++ *             strings in hex mode if any non-printable char
++ *             is contained within the string.
++ *
++ *     27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
++ *             Changed --tos to --string in save(). Also
++ *             updated to work with slightly modified
++ *             ipt_string_info.
++ */
++#define _GNU_SOURCE 1 /* strnlen for older glibcs */
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++#include <ctype.h>
++#include <xtables.h>
++#include <linux/netfilter/xt_conndict.h>
++
++enum {
++	O_FIELD = 0,
++	O_VALUE,
++	O_SET,
++	F_FIELD      = 1 << O_FIELD,
++	F_VALUE      = 1 << O_VALUE,
++	F_SET        = 1 << O_SET,
++	F_OP_ANY     = F_FIELD | F_VALUE | F_SET,
++};
++
++static void dict_help(void)
++{
++	printf(
++"conndict match options:\n"
++"[!] --field string --value string    Match a string in a packet\n"
++"    --set                            Set field value pair on a connection");
++}
++
++#define s struct xt_dict_info
++static const struct xt_option_entry dict_opts[] = {
++	{.name = "field", .id = O_FIELD, .type = XTTYPE_STRING,
++	 .flags = XTOPT_INVERT | XTOPT_MAND | XTOPT_PUT, XTOPT_POINTER(s, field), .also = F_VALUE},
++	{.name = "value", .id = O_VALUE, .type = XTTYPE_STRING,
++	 .flags = XTOPT_INVERT | XTOPT_MAND | XTOPT_PUT, XTOPT_POINTER(s, value), .also = F_FIELD},
++	{.name = "set", .id = O_SET, .type = XTTYPE_NONE},
++	XTOPT_TABLEEND,
++};
++#undef s
++
++static void dict_init(struct xt_entry_match *m)
++{
++	struct xt_dict_info *i = (struct xt_dict_info *) m->data;
++	memset(i, 0, sizeof(*i));
++}
++
++static void dict_parse(struct xt_option_call *cb)
++{
++	struct xt_dict_info *dict_info = cb->data;
++
++	xtables_option_parse(cb);
++
++	if(cb->entry->id == O_SET) {
++		dict_info->flags |= XT_CONNDICT_FLAG_SET;
++		return;
++	}
++
++	if (cb->invert) {
++		dict_info->flags |= XT_CONNDICT_FLAG_INVERT;
++	}
++
++	dict_info->field_len = strnlen(dict_info->field, XT_CONNDICT_MAX_PATTERN_SIZE);
++	dict_info->value_len = strnlen(dict_info->value, XT_CONNDICT_MAX_PATTERN_SIZE);
++}
++
++static void dict_check(struct xt_fcheck_call *cb)
++{
++	if (!(cb->xflags & F_OP_ANY))
++		xtables_error(PARAMETER_PROBLEM,
++			   "conndict match: You must specify"
++			   "`--field' and `--value'");
++}
++
++static void
++dict_print(const void *ip, const struct xt_entry_match *match, int numeric)
++{
++	const struct xt_dict_info *info =
++	    (const struct xt_dict_info*) match->data;
++	int invert = info->flags & XT_CONNDICT_FLAG_INVERT;
++
++	printf(" conndict match %s FIELD \"%s\" VALUE \"%s\"", (invert) ? " !": "", info->field, info->value);
++
++	if(info->flags & XT_CONNDICT_FLAG_SET) {
++		printf(" set");
++	}
++}
++
++static void dict_save(const void *ip, const struct xt_entry_match *match)
++{
++	const struct xt_dict_info *info =
++	    (const struct xt_dict_info*) match->data;
++	int invert = info->flags & XT_CONNDICT_FLAG_INVERT;
++
++	printf("%s --field", (invert) ? " !": "");
++	xtables_save_string(info->field);
++	printf("--value");
++	xtables_save_string(info->value);
++
++	if(info->flags & XT_CONNDICT_FLAG_SET) {
++		printf(" --set");
++	}
++}
++
++static struct xtables_match string_mt_reg[] = {
++	{
++		.name          = "conndict",
++		.revision      = 0,
++		.family        = NFPROTO_UNSPEC,
++		.version       = XTABLES_VERSION,
++		.size          = XT_ALIGN(sizeof(struct xt_dict_info)),
++		.userspacesize = offsetof(struct xt_dict_info, field_hash),
++		.help          = dict_help,
++		.init          = dict_init,
++		.print         = dict_print,
++		.save          = dict_save,
++		.x6_parse      = dict_parse,
++		.x6_fcheck     = dict_check,
++		.x6_options    = dict_opts,
++	},
++};
++
++void _init(void)
++{
++	xtables_register_matches(string_mt_reg, ARRAY_SIZE(string_mt_reg));
++}
+diff --git a/extensions/libxt_conndict.man b/extensions/libxt_conndict.man
+new file mode 100644
+index 00000000..1a5f8514
+--- /dev/null
++++ b/extensions/libxt_conndict.man
+@@ -0,0 +1,14 @@
++This modules matches a given field/value pair by using some pattern matching strategy. It requires a patch to the linux kernel.
++.TP
++[\fB!\fP] \fB\-\-field\fP \fIstring\fP \fB\-\-value\fP \fIstring\fP
++Defines the field and value to match
++.TP
++Examples:
++.IP
++# The --field and --value values can be used for exact matching.
++.br
++iptables \-A INPUT \-p tcp \-m session \-\-field 'username' \-\-field 'bob' \-j LOG
++.IP
++# The --field and --value values can also be used with wildcards.
++.br
++iptables \-A INPUT \-p tcp \-m session \-\-field 'username' \-\-field 'b*' \-j LOG
+-- 
+2.11.0
+
diff --git a/target/linux/generic/backport-4.14/369-netfilter-Add-conndict.patch b/target/linux/generic/backport-4.14/369-netfilter-Add-conndict.patch
new file mode 100644
index 0000000000..afbe07e8ba
--- /dev/null
+++ b/target/linux/generic/backport-4.14/369-netfilter-Add-conndict.patch
@@ -0,0 +1,1540 @@
+From d7eb897cd901dd853190f73e8e664f88485b5f71 Mon Sep 17 00:00:00 2001
+From: Brett Mastbergen <bmastbergen@untangle.com>
+Date: Fri, 9 Feb 2018 14:14:03 -0500
+Subject: [PATCH] netfilter: Add conndict
+
+Netfilter conndict support allows arbitrary field/value pairs to
+be attached to conntrack entries.  Those field/value pairs can then
+be matched via iptables and/or nftables.  conndict support can be
+configured as a conntrack extension built into the kernel binary or
+as a module via livepatching.
+---
+ include/net/netfilter/nf_conntrack_dict.h   |  51 +++
+ include/net/netfilter/nf_conntrack_extend.h |   4 +
+ include/uapi/linux/netfilter/nf_tables.h    |  10 +
+ include/uapi/linux/netfilter/xt_conndict.h  |  25 ++
+ net/netfilter/Kconfig                       |  45 +++
+ net/netfilter/Makefile                      |   6 +
+ net/netfilter/nf_conntrack_core.c           |   9 +
+ net/netfilter/nf_conntrack_dict_core.c      | 597 ++++++++++++++++++++++++++++
+ net/netfilter/nf_conntrack_dict_ext.c       |  56 +++
+ net/netfilter/nf_conntrack_dict_livepatch.c | 269 +++++++++++++
+ net/netfilter/nft_dict.c                    | 165 ++++++++
+ net/netfilter/xt_conndict.c                 | 103 +++++
+ 13 files changed, 1341 insertions(+)
+ create mode 100644 include/net/netfilter/nf_conntrack_dict.h
+ create mode 100644 include/uapi/linux/netfilter/xt_conndict.h
+ create mode 100644 net/netfilter/nf_conntrack_dict_core.c
+ create mode 100644 net/netfilter/nf_conntrack_dict_ext.c
+ create mode 100644 net/netfilter/nf_conntrack_dict_livepatch.c
+ create mode 100644 net/netfilter/nft_dict.c
+ create mode 100644 net/netfilter/xt_conndict.c
+
+diff --git a/include/net/netfilter/nf_conntrack_dict.h b/include/net/netfilter/nf_conntrack_dict.h
+new file mode 100644
+index 000000000000..cdfcbd89030c
+--- /dev/null
++++ b/include/net/netfilter/nf_conntrack_dict.h
+@@ -0,0 +1,51 @@
++#include <linux/types.h>
++#include <linux/rhashtable.h>
++#include <linux/netfilter/nf_conntrack_common.h>
++#include <linux/netfilter/nf_conntrack_tuple_common.h>
++#include <net/net_namespace.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_extend.h>
++
++struct nf_conn_dict {
++	struct rhash_head node;
++	struct nf_conn * key;
++	struct rhashtable pair_ht;
++};
++
++struct nf_conn_dict_pair_string {
++	char * str;
++	int len;
++	u32 hash;
++};
++
++struct nf_conn_dict_pair {
++	struct rhash_head node;
++	struct nf_conn_dict_pair_string * field;
++	struct nf_conn_dict_pair_string * value;
++	unsigned int ct_id;
++};
++
++#ifdef CONFIG_NF_CONNTRACK_DICT
++struct nf_conn_dict *nf_ct_dict_ext_add(struct nf_conn *ct);
++#else
++static inline struct nf_conn_dict *nf_ct_dict_ext_add(struct nf_conn *ct)
++{
++	return NULL;
++}
++#endif
++
++void nf_conntrack_dict_disable(void);
++int nf_conntrack_dict_enable(void);
++void new_dict(struct nf_conn *ct);
++void destroy_dict(struct nf_conn *ct);
++struct nf_conn_dict * find_conntrack_dict(struct nf_conn *ct);
++struct nf_conn_dict_pair * find_conntrack_dict_pair(struct nf_conn_dict * dict, u32 * hash);
++void new_dict_pair(struct nf_conn_dict *dict, char * field, char * value);
++
++#ifdef CONFIG_NF_CONNTRACK_DICT
++int nf_conntrack_dict_init(void);
++void nf_conntrack_dict_fini(void);
++#else
++static inline int nf_conntrack_dict_init(void) { return 0; }
++static inline void nf_conntrack_dict_fini(void) {}
++#endif
+diff --git a/include/net/netfilter/nf_conntrack_extend.h b/include/net/netfilter/nf_conntrack_extend.h
+index 1c3035dda31f..c45155e4c627 100644
+--- a/include/net/netfilter/nf_conntrack_extend.h
++++ b/include/net/netfilter/nf_conntrack_extend.h
+@@ -27,6 +27,9 @@ enum nf_ct_ext_id {
+ #if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
+	NF_CT_EXT_RTCACHE,
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_DICT
++	NF_CT_EXT_DICT,
++#endif
+ 	NF_CT_EXT_NUM,
+ };
+ 
+@@ -39,6 +40,7 @@ enum nf_ct_ext_id {
+ #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
+ #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
+ #define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
++#define NF_CT_EXT_DICT_TYPE struct nf_conn_dict
+ 
+ /* Extensions: optional stuff which isn't permanently in struct. */
+ struct nf_ct_ext {
+diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
+index c6c4477c136b..88bf44e90d17 100644
+--- a/include/uapi/linux/netfilter/nf_tables.h
++++ b/include/uapi/linux/netfilter/nf_tables.h
+@@ -1186,4 +1186,14 @@ enum nft_ng_types {
+ };
+ #define NFT_NG_MAX	(__NFT_NG_MAX - 1)
+ 
++enum nft_dict_attributes {
++	NFTA_DICT_UNSPEC,
++	NFTA_DICT_FIELD,
++	NFTA_DICT_VALUE,
++	NFTA_DICT_SET,
++	__NFTA_DICT_MAX,
++};
++
++#define NFTA_DICT_MAX (__NFTA_DICT_MAX - 1)
++
+ #endif /* _LINUX_NF_TABLES_H */
+diff --git a/include/uapi/linux/netfilter/xt_conndict.h b/include/uapi/linux/netfilter/xt_conndict.h
+new file mode 100644
+index 000000000000..ca67c84d3785
+--- /dev/null
++++ b/include/uapi/linux/netfilter/xt_conndict.h
+@@ -0,0 +1,25 @@
++#ifndef _XT_CONNDICT_H
++#define _XT_CONNDICT_H
++
++#include <linux/types.h>
++
++#define XT_CONNDICT_MAX_PATTERN_SIZE 128
++
++enum {
++	XT_CONNDICT_FLAG_INVERT		= 1 << 0,
++	XT_CONNDICT_FLAG_SET		= 1 << 1,
++};
++
++struct xt_dict_info {
++	__u8  flags;
++
++	char	field[XT_CONNDICT_MAX_PATTERN_SIZE];
++	__u8	field_len;
++	char	value[XT_CONNDICT_MAX_PATTERN_SIZE];
++	__u8	value_len;
++
++	__u32	field_hash;
++	__u32	value_hash;
++};
++
++#endif /*_XT_CONNDICT_H*/
+diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
+index e8d56d9a4df2..c8d361e6e15f 100644
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -114,6 +114,17 @@ config NF_CONNTRACK_EVENTS
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_DICT
++	bool  'Connection tracking dictionary'
++	depends on NETFILTER_ADVANCED
++	depends on !NF_CONNTRACK_DICT_LIVEPATCH || NF_CONNTRACK_DICT_LIVEPATCH
++	help
++	  This option enables support for assigning layer 7 fields such as
++	  username or hostname to connection tracking entries. It is meant
++	  to be enabled with the netfilter dictionary match.
++
++	  If unsure, say `N'.
++
+ config NF_CONNTRACK_TIMEOUT
+ 	bool  'Connection tracking timeout'
+ 	depends on NETFILTER_ADVANCED
+@@ -371,6 +382,20 @@ config NETFILTER_NETLINK_GLUE_CT
+ 	  Connection Tracking information together with the packet is
+ 	  the enqueued via NFNETLINK.
+ 
++config NF_CONNTRACK_DICT_LIVEPATCH
++	tristate  'Connection tracking dictionary via livepatching'
++	depends on NETFILTER_ADVANCED
++	depends on LIVEPATCH
++	depends on !NF_CONNTRACK_DICT || NF_CONNTRACK_DICT
++	help
++	  This option enables support for assigning layer 7 fields such as
++	  username or hostname to connection tracking entries. It is meant
++	  to be enabled with the netfilter dictionary match.  This option relies
++	  on livepatching the kernel's init_conntrack and destroy_conntrack functions
++	  instead of a conntrack extension (like NF_CONNTRACK_DICT).
++
++	  If unsure, say `N'.
++
+ config NF_NAT
+ 	tristate
+ 
+@@ -575,6 +600,14 @@ config NFT_COMPAT
+ 	  x_tables match/target extensions over the nf_tables
+ 	  framework.
+ 
++config NFT_DICT
++	depends on NETFILTER_XTABLES
++	depends on NF_CONNTRACK_DICT || NF_CONNTRACK_DICT_LIVEPATCH
++	tristate "Netfilter nf_tables conntrack dict module"
++	help
++	  This match allows you to test and assign layer 7 fields
++	  such as username or hostname to a connection.
++
+ config NFT_HASH
+ 	tristate "Netfilter nf_tables hash module"
+ 	help
+@@ -1405,6 +1438,18 @@ config NETFILTER_XT_MATCH_SCTP
+ 	  If you want to compile it as a module, say M here and read
+ 	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
+ 
++config NETFILTER_XT_MATCH_CONNDICT
++	tristate '"conndict" match support'
++	depends on NF_CONNTRACK
++	depends on NETFILTER_ADVANCED
++	depends on NF_CONNTRACK_DICT || NF_CONNTRACK_DICT_LIVEPATCH
++	---help---
++	  This match allows you to test and assign layer 7 fields
++	  such as username or hostname to a connection.
++
++	  If you want to compile it as a module, say M here and read
++	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
++
+ config NETFILTER_XT_MATCH_SOCKET
+ 	tristate '"socket" match support'
+ 	depends on NETFILTER_XTABLES
+diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
+index c23c3c84416f..175feaba2907 100644
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -5,6 +5,10 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMEOUT) += nf_conntrack_timeout.o
+ nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
++nf_conntrack-$(CONFIG_NF_CONNTRACK_DICT) += nf_conntrack_dict_ext.o nf_conntrack_dict_core.o
++
++nf_conntrack_dict-objs += nf_conntrack_dict_livepatch.o nf_conntrack_dict_core.o
++obj-$(CONFIG_NF_CONNTRACK_DICT_LIVEPATCH) += nf_conntrack_dict.o
+ 
+ obj-$(CONFIG_NETFILTER) = netfilter.o
+ 
+@@ -79,6 +83,7 @@ obj-$(CONFIG_NF_TABLES)		+= nf_tables.o
+ obj-$(CONFIG_NF_TABLES_INET)	+= nf_tables_inet.o
+ obj-$(CONFIG_NF_TABLES_NETDEV)	+= nf_tables_netdev.o
+ obj-$(CONFIG_NFT_COMPAT)	+= nft_compat.o
++obj-$(CONFIG_NFT_DICT)		+= nft_dict.o
+ obj-$(CONFIG_NFT_EXTHDR)	+= nft_exthdr.o
+ obj-$(CONFIG_NFT_META)		+= nft_meta.o
+ obj-$(CONFIG_NFT_NUMGEN)	+= nft_numgen.o
+@@ -140,6 +145,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_BPF) += xt_bpf.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_CLUSTER) += xt_cluster.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_COMMENT) += xt_comment.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_CONNBYTES) += xt_connbytes.o
++obj-$(CONFIG_NETFILTER_XT_MATCH_CONNDICT) += xt_conndict.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_CONNLABEL) += xt_connlabel.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_CONNLIMIT) += xt_connlimit.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_CONNTRACK) += xt_conntrack.o
+diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
+index 750b8bf13e60..1b4b5b6764e6 100644
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -51,6 +51,7 @@
+ #include <net/netfilter/nf_conntrack_timeout.h>
+ #include <net/netfilter/nf_conntrack_labels.h>
+ #include <net/netfilter/nf_conntrack_synproxy.h>
++#include <net/netfilter/nf_conntrack_dict.h>
+ #include <net/netfilter/nf_nat.h>
+ #include <net/netfilter/nf_nat_core.h>
+ #include <net/netfilter/nf_nat_helper.h>
+@@ -1172,6 +1173,7 @@ init_conntrack(struct net *net, struct nf_conn *tmpl,
+ 	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
+ 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
+ 	nf_ct_labels_ext_add(ct);
++	nf_ct_dict_ext_add(ct);
+ 
+ 	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
+ 	nf_ct_ecache_ext_add(ct, ecache ? ecache->ctmask : 0,
+@@ -1648,6 +1650,7 @@ void nf_conntrack_cleanup_end(void)
+ 	cancel_delayed_work_sync(&conntrack_gc_work.dwork);
+ 	nf_ct_free_hashtable(nf_conntrack_hash, nf_conntrack_htable_size);
+ 
++	nf_conntrack_dict_fini();
+ 	nf_conntrack_proto_fini();
+ 	nf_conntrack_seqadj_fini();
+ 	nf_conntrack_labels_fini();
+@@ -1912,6 +1915,10 @@ int nf_conntrack_init_start(void)
+ 	if (ret < 0)
+ 		goto err_proto;
+ 
++	ret = nf_conntrack_dict_init();
++	if (ret < 0)
++		goto err_dict;
++
+	conntrack_gc_work_init(&conntrack_gc_work);
+	queue_delayed_work(system_long_wq, &conntrack_gc_work.dwork, HZ);
+
+@@ -1926,6 +1933,8 @@ int nf_conntrack_init_start(void)
+ 
+ 	return 0;
+ 
++err_dict:
++	nf_conntrack_proto_fini();
+ err_proto:
+ 	nf_conntrack_seqadj_fini();
+ err_seqadj:
+diff --git a/net/netfilter/nf_conntrack_dict_core.c b/net/netfilter/nf_conntrack_dict_core.c
+new file mode 100644
+index 000000000000..bd7f74015751
+--- /dev/null
++++ b/net/netfilter/nf_conntrack_dict_core.c
+@@ -0,0 +1,597 @@
++#include <linux/module.h>
++#include <linux/proc_fs.h>
++#include <linux/rhashtable.h>
++#include <linux/glob.h>
++#include <linux/jhash.h>
++#include <linux/parser.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_dict.h>
++
++static struct proc_dir_entry *dict_dir;
++static struct rhashtable ht;
++
++static const struct rhashtable_params dict_rhashtable_params = {
++	.head_offset = offsetof(struct nf_conn_dict, node),
++	.key_offset = offsetof(struct nf_conn_dict, key),
++	.key_len = sizeof(struct nf_conn *),
++	.automatic_shrinking = true,
++};
++
++static inline int pair_hash_cmp(struct rhashtable_compare_arg *arg, const void *ptr)
++{
++	struct nf_conn_dict_pair * pair = (struct nf_conn_dict_pair *)ptr;
++	u32 hash = *(u32 *)arg->key;
++
++	return !(hash == pair->field->hash);
++}
++
++static inline u32 pair_hash_obj(const void *data, u32 len, u32 seed)
++{
++	struct nf_conn_dict_pair * pair = (struct nf_conn_dict_pair *) data;
++
++	return pair->field->hash;
++}
++
++static inline u32 pair_hash_key(const void *data, u32 len, u32 seed)
++{
++	u32 hash = *(u32 *)data;
++
++	return hash;
++}
++
++static const struct rhashtable_params pair_rhashtable_params = {
++	.head_offset = offsetof(struct nf_conn_dict_pair, node),
++	.hashfn	= pair_hash_key,
++	.obj_hashfn = pair_hash_obj,
++	.obj_cmpfn = pair_hash_cmp,
++	.automatic_shrinking = true,
++};
++
++static struct nf_conn_dict * find_dict_by_id(unsigned int id)
++{
++	struct rhashtable_iter hti;
++	struct nf_conn_dict *dict, *ret_dict = NULL;
++	unsigned int err;
++
++	err = rhashtable_walk_init(&ht, &hti, GFP_KERNEL);
++	if (err) {
++		pr_err("%s: rhashtable_walk_init failed: allocation error: %d", __func__, err);
++		return NULL;
++	}
++
++	err = rhashtable_walk_start(&hti);
++	if (err && err != -EAGAIN) {
++		pr_err("%s: rhashtable_walk_start failed: %d\n", __func__, err);
++		return NULL;
++	}
++
++	while ((dict = rhashtable_walk_next(&hti)) && !IS_ERR(dict)) {
++		unsigned int ct_id = (unsigned long)dict->key;
++
++		if(ct_id == id) {
++			ret_dict = dict;
++			break;
++		}
++	}
++
++	rhashtable_walk_stop(&hti);
++	rhashtable_walk_exit(&hti);
++
++	return ret_dict;
++}
++
++static int show_dict(struct seq_file *m, struct nf_conn_dict *dict)
++{
++	struct rhashtable *ht = &dict->pair_ht;
++	struct rhashtable_iter hti;
++	struct nf_conn_dict_pair *pair;
++	unsigned int err;
++	unsigned int ct_id;
++
++	ct_id = (unsigned long)dict->key;
++	seq_printf(m, "id: %u\n", ct_id);
++
++	err = rhashtable_walk_init(ht, &hti, GFP_KERNEL);
++	if (err) {
++		pr_err("%s: rhashtable_walk_init failed: allocation error: %d", __func__, err);
++		return err;
++	}
++
++	err = rhashtable_walk_start(&hti);
++	if (err && err != -EAGAIN) {
++		pr_err("%s: rhashtable_walk_start failed: %d\n", __func__, err);
++		return err;
++	}
++
++	while ((pair = rhashtable_walk_next(&hti)) && !IS_ERR(dict)) {
++		seq_printf(m, "%s: %s\n", pair->field->str, pair->value->str);
++	}
++
++	rhashtable_walk_stop(&hti);
++	rhashtable_walk_exit(&hti);
++
++	return 0;
++}
++
++static int all_dict_show(struct seq_file *m, void *v)
++{
++	struct rhashtable *ht = (struct rhashtable *)m->private;
++	struct rhashtable_iter hti;
++	struct nf_conn_dict *dict;
++	unsigned int err;
++
++	err = rhashtable_walk_init(ht, &hti, GFP_KERNEL);
++	if (err) {
++		pr_err("%s: rhashtable_walk_init failed: allocation error: %d", __func__, err);
++		return err;
++	}
++
++	err = rhashtable_walk_start(&hti);
++	if (err && err != -EAGAIN) {
++		pr_err("%s: rhashtable_walk_start failed: %d\n", __func__, err);
++		return err;
++	}
++
++	while ((dict = rhashtable_walk_next(&hti)) && !IS_ERR(dict)) {
++		show_dict(m, dict);
++	}
++
++	rhashtable_walk_stop(&hti);
++	rhashtable_walk_exit(&hti);
++
++	return 0;
++}
++
++static int all_dict_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, all_dict_show, PDE_DATA(inode));
++}
++
++static const struct file_operations all_dict_file_ops = {
++	.owner   = THIS_MODULE,
++	.open    = all_dict_open,
++	.read    = seq_read,
++	.llseek  = seq_lseek,
++	.release = single_release,
++};
++
++static int all_show(struct seq_file *m, void *v)
++{
++	struct nf_conn_dict *dict = (struct nf_conn_dict *)m->private;
++
++	show_dict(m, dict);
++
++	return 0;
++}
++
++static int all_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, all_show, PDE_DATA(inode));
++}
++
++enum {
++	Opt_id,
++	Opt_field,
++	Opt_value,
++	Opt_err,
++};
++
++static const match_table_t tokens = {
++	{Opt_id, "id=%u"},
++	{Opt_field, "field=%s"},
++	{Opt_value, "value=%s"},
++	{Opt_err, NULL},
++};
++
++static int match_uint(substring_t *s, unsigned int *result)
++{
++	char *buf;
++	int ret;
++	unsigned int val;
++	size_t len = s->to - s->from;
++
++	buf = kmalloc(len + 1, GFP_KERNEL);
++	if (!buf)
++		return -ENOMEM;
++
++	memcpy(buf, s->from, len);
++	buf[len] = '\0';
++
++	ret = kstrtouint(buf, 0, &val);
++	if(!ret)
++		*result = val;
++
++	kfree(buf);
++	return ret;
++}
++
++static ssize_t top_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)
++{
++	char * orig, * local_buf, * p, * field = NULL, * value = NULL;
++	unsigned int id = 0;
++	struct nf_conn_dict *dict = PDE_DATA(file_inode(file));
++	substring_t args[MAX_OPT_ARGS];
++
++	orig = local_buf = kzalloc(size, GFP_KERNEL);
++	if(!local_buf) {
++		pr_err("%s: Could not allocate local buffer!\n", __func__);
++		goto err;
++	}
++
++	if (copy_from_user(local_buf, buf, size) != 0) {
++		pr_err("%s: copy_from_user failed!\n", __func__);
++		goto free_local_buf;
++	}
++
++	while ((p = strsep(&local_buf, ","))) {
++		int token;
++
++		if (!*p)
++			continue;
++
++		token = match_token(p, tokens, args);
++		switch (token) {
++			case Opt_id:
++				{
++					int ret = 0;
++					ret = match_uint(&args[0], &id);
++					if(ret) {
++						pr_err("%s: Opt_id failed %d\n", __func__, ret);
++						goto free_local_buf;
++					}
++					break;
++				}
++			case Opt_field:
++				{
++					field = match_strdup(&args[0]);
++					break;
++				}
++			case Opt_value:
++				{
++					value = match_strdup(&args[0]);
++					break;
++				}
++
++			default:
++				pr_err("unrecognized option \"%s\" "
++				       "or missing value\n", p);
++				break;
++		}
++	}
++
++	if(id != 0 && field && value) {
++		dict = find_dict_by_id(id);
++		if(dict) {
++			new_dict_pair(dict, field, value);
++		}
++	} else {
++		pr_err("%s: Insuffient input\n", __func__);
++	}
++
++	kfree(field);
++	kfree(value);
++free_local_buf:
++	kfree(orig);
++err:
++	return size;
++}
++
++static const struct file_operations top_write_file_ops = {
++	.owner   = THIS_MODULE,
++	.open    = all_open,
++	.read    = seq_read,
++	.write   = top_write,
++	.llseek  = seq_lseek,
++	.release = single_release,
++};
++
++static unsigned int read_id = 0;
++static int top_show(struct seq_file *m, void *v)
++{
++	struct nf_conn_dict *dict;
++
++	dict = find_dict_by_id(read_id);
++	if(dict) {
++		show_dict(m, dict);
++	}
++
++	return 0;
++}
++
++static int top_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, top_show, PDE_DATA(inode));
++}
++
++static ssize_t read_id_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)
++{
++
++	int ret;
++
++	ret = kstrtouint_from_user(buf, size, 10, &read_id);
++	if(ret) {
++		return ret;
++	}
++
++	return size;
++}
++
++static const struct file_operations top_read_file_ops = {
++	.owner   = THIS_MODULE,
++	.open    = top_open,
++	.read    = seq_read,
++	.write   = read_id_write,
++	.llseek  = seq_lseek,
++	.release = single_release,
++};
++
++static struct nf_conn_dict_pair_string * alloc_dict_pair_string(int string_size)
++{
++	struct nf_conn_dict_pair_string * new;
++
++	new = kzalloc(sizeof(*new), GFP_KERNEL);
++	if(!new) {
++		pr_err("%s: Could not allocate new pair string\n", __func__);
++		goto err;
++	}
++
++	new->str = kzalloc(string_size, GFP_KERNEL);
++	if(!new->str) {
++		pr_err("%s: Could not allocate new string\n", __func__);
++		goto err_free_new;
++	}
++
++	return new;
++
++err_free_new:
++	kfree(new);
++err:
++	return NULL;
++}
++
++static void free_dict_pair_string(struct nf_conn_dict_pair_string * dict_pair_string)
++{
++	kfree(dict_pair_string->str);
++	kfree(dict_pair_string);
++}
++
++static void free_pair(struct nf_conn_dict_pair *pair)
++{
++	free_dict_pair_string(pair->field);
++	free_dict_pair_string(pair->value);
++	kfree(pair);
++}
++
++void new_dict_pair(struct nf_conn_dict *dict, char * field, char * value)
++{
++	struct nf_conn_dict_pair * pair;
++	struct nf_conn_dict_pair_string * new_value, * old_value;
++	int ret;
++	u32 hash;
++
++	new_value = alloc_dict_pair_string(strlen(value) + 1);
++	if(!new_value) {
++		pr_err("%s: Could not allocate new_value\n", __func__);
++		return;
++	}
++
++	strcpy(new_value->str, value);
++	new_value->len = strlen(new_value->str);
++	new_value->hash = jhash(new_value->str, new_value->len, 0);
++
++	hash = jhash(field, strlen(field), 0);
++
++	rcu_read_lock();
++	pair = rhashtable_lookup_fast(&dict->pair_ht, &hash, pair_rhashtable_params);
++	rcu_read_unlock();
++	if(!pair) {
++		pair = kzalloc(sizeof(*pair), GFP_KERNEL);
++		if(!pair) {
++			pr_err("%s: Could not allocate pair structure\n", __func__);
++			free_dict_pair_string(new_value);
++			return;
++		}
++
++		pair->field = alloc_dict_pair_string(strlen(field) + 1);
++		if(!pair->field) {
++			pr_err("%s: Could not allocate pair->field\n", __func__);
++			free_dict_pair_string(new_value);
++			kfree(pair);
++			return;
++		}
++
++		strcpy(pair->field->str, field);
++		pair->field->len = strlen(pair->field->str);
++		pair->field->hash = hash;
++		pair->ct_id = (unsigned long)dict->key;
++		pair->value = new_value;
++
++		ret = rhashtable_lookup_insert_key(&dict->pair_ht, &pair->field->hash, &pair->node, pair_rhashtable_params);
++		if(ret < 0) {
++			pr_err("%s: Unable to insert pair into hashtable: %d\n", __func__, ret);
++			free_pair(pair);
++			return;
++		}
++
++	} else {
++		old_value = rcu_dereference(pair->value);
++		rcu_assign_pointer(pair->value, new_value);
++		free_dict_pair_string(old_value);
++	}
++
++	return;
++}
++EXPORT_SYMBOL_GPL(new_dict_pair);
++
++void new_dict(struct nf_conn *ct)
++{
++	struct nf_conn_dict * dict;
++	int ret;
++
++	dict = kzalloc(sizeof(*dict), GFP_KERNEL);
++	if(!dict) {
++		pr_err("%s: Could not allocate dict structure\n", __func__);
++		return;
++	}
++
++	dict->key = ct;
++
++	ret = rhashtable_lookup_insert_fast(&ht, &dict->node, dict_rhashtable_params);
++	if(ret < 0) {
++		pr_err("%s: Unable to insert dict into hashtable: %d\n", __func__, ret);
++		kfree(dict);
++		return;
++	}
++
++	ret = rhashtable_init(&dict->pair_ht, &pair_rhashtable_params);
++	if(ret < 0) {
++		pr_err("%s: Unable to initialize pair hashtable: %d\n", __func__, ret);
++		return;
++	}
++}
++
++static void free_dict_pair(void *ptr, void *arg)
++{
++	struct nf_conn_dict_pair * pair = (struct nf_conn_dict_pair *)ptr;
++
++	free_pair(pair);
++}
++
++static void __free_dict(struct nf_conn_dict * dict)
++{
++	if(!dict)
++		return;
++
++	rhashtable_free_and_destroy(&dict->pair_ht, free_dict_pair, NULL);
++
++	kfree(dict);
++}
++
++static void free_dict(void *ptr, void *arg)
++{
++	struct nf_conn_dict * dict = (struct nf_conn_dict *)ptr;
++
++	__free_dict(dict);
++}
++
++struct nf_conn_dict * find_conntrack_dict(struct nf_conn *ct)
++{
++	struct nf_conn_dict * dict;
++
++	rcu_read_lock();
++	dict = rhashtable_lookup_fast(&ht, &ct, dict_rhashtable_params);
++	rcu_read_unlock();
++
++	return dict;
++}
++EXPORT_SYMBOL_GPL(find_conntrack_dict);
++
++struct nf_conn_dict_pair * find_conntrack_dict_pair(struct nf_conn_dict * dict, u32 * hash)
++{
++	struct nf_conn_dict_pair * pair;
++
++	rcu_read_lock();
++	pair = rhashtable_lookup_fast(&dict->pair_ht, hash, pair_rhashtable_params);
++	rcu_read_unlock();
++
++	return pair;
++}
++EXPORT_SYMBOL_GPL(find_conntrack_dict_pair);
++
++void destroy_dict(struct nf_conn *ct)
++{
++	struct nf_conn_dict * dict;
++	int ret;
++
++	dict = find_conntrack_dict(ct);
++	if(!dict) {
++		return;
++	}
++
++	ret = rhashtable_remove_fast(&ht, &dict->node, dict_rhashtable_params);
++	if(ret < 0) {
++		pr_err("%s: Unable to remove seession from hashtable: %d\n", __func__, ret);
++		return;
++	}
++
++	__free_dict(dict);
++}
++
++static int __net_init dict_net_init(struct net *net)
++{
++	int ret = 0;
++	struct proc_dir_entry * temp;
++
++	dict_dir = proc_net_mkdir(net, "dict", net->proc_net);
++	if (!dict_dir) {
++		pr_err("cannot create dict proc entry");
++		return -ENOMEM;
++	}
++
++	temp = proc_create_data("all", 0440, dict_dir, &all_dict_file_ops, &ht);
++	if (!temp) {
++		pr_err("cannot create all proc");
++		remove_proc_entry("dict", net->proc_net);
++		return -ENOMEM;
++	}
++
++	temp = proc_create_data("write", 0440, dict_dir, &top_write_file_ops, NULL);
++	if (!temp) {
++		remove_proc_entry("all", dict_dir);
++		pr_err("cannot create write proc");
++		return -ENOMEM;
++	}
++
++	temp = proc_create_data("read", 0440, dict_dir, &top_read_file_ops, NULL);
++	if (!temp) {
++		remove_proc_entry("write", dict_dir);
++		remove_proc_entry("all", dict_dir);
++		pr_err("cannot create read proc");
++		return -ENOMEM;
++	}
++
++	return ret;
++}
++
++static void __net_exit dict_net_exit(struct net *net)
++{
++	remove_proc_entry("read", dict_dir);
++	remove_proc_entry("write", dict_dir);
++	remove_proc_entry("all", dict_dir);
++	remove_proc_entry("dict", net->proc_net);
++}
++
++static struct pernet_operations dict_net_ops = {
++	.init = dict_net_init,
++	.exit = dict_net_exit,
++};
++
++void nf_conntrack_dict_disable(void)
++{
++	unregister_pernet_subsys(&dict_net_ops);
++	rhashtable_free_and_destroy(&ht, free_dict, NULL);
++}
++
++int nf_conntrack_dict_enable(void)
++{
++	int err = 0;
++
++	err = rhashtable_init(&ht, &dict_rhashtable_params);
++	if(err < 0) {
++		pr_err("%s: Unable to initialize hashtable: %d\n", __func__, err);
++		goto err;
++	}
++
++	err = register_pernet_subsys(&dict_net_ops);
++	if (err) {
++		goto err_destroy_rhashtable;
++	}
++
++	return 0;
++
++err_destroy_rhashtable:
++	rhashtable_free_and_destroy(&ht, free_dict, NULL);
++err:
++	return err;
++}
++
+diff --git a/net/netfilter/nf_conntrack_dict_ext.c b/net/netfilter/nf_conntrack_dict_ext.c
+new file mode 100644
+index 000000000000..713bd74290bd
+--- /dev/null
++++ b/net/netfilter/nf_conntrack_dict_ext.c
+@@ -0,0 +1,56 @@
++/*
++ *
++ * (C) 2013 Astaro GmbH & Co KG
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/export.h>
++#include <linux/types.h>
++
++#include <net/netfilter/nf_conntrack_dict.h>
++
++struct nf_conn_dict *nf_ct_dict_ext_add(struct nf_conn *ct)
++{
++	struct nf_conn_dict * dict;
++
++	dict = nf_ct_ext_add(ct, NF_CT_EXT_DICT, GFP_ATOMIC);
++	if(dict) {
++		new_dict(ct);
++	}
++
++	return dict;
++}
++
++static void nf_dict_destroy(struct nf_conn *ct)
++{
++	destroy_dict(ct);
++}
++
++static struct nf_ct_ext_type dict_extend __read_mostly = {
++	.len    = sizeof(struct nf_conn_dict *),
++	.align  = __alignof__(struct nf_conn_dict *),
++	.destroy	= nf_dict_destroy,
++	.id     = NF_CT_EXT_DICT,
++};
++
++int nf_conntrack_dict_init(void)
++{
++
++	int err = 0;
++
++	err = nf_conntrack_dict_enable();
++	if (err) {
++		return err;
++	}
++
++	return nf_ct_extend_register(&dict_extend);
++}
++
++void nf_conntrack_dict_fini(void)
++{
++	nf_ct_extend_unregister(&dict_extend);
++	nf_conntrack_dict_disable();
++}
+diff --git a/net/netfilter/nf_conntrack_dict_livepatch.c b/net/netfilter/nf_conntrack_dict_livepatch.c
+new file mode 100644
+index 000000000000..584e2c5e8e78
+--- /dev/null
++++ b/net/netfilter/nf_conntrack_dict_livepatch.c
+@@ -0,0 +1,269 @@
++#include <linux/module.h>
++#include <linux/livepatch.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_acct.h>
++#include <net/netfilter/nf_conntrack_dict.h>
++#include <net/netfilter/nf_conntrack_core.h>
++#include <net/netfilter/nf_conntrack_expect.h>
++#include <net/netfilter/nf_conntrack_helper.h>
++#include <net/netfilter/nf_conntrack_l4proto.h>
++#include <net/netfilter/nf_conntrack_labels.h>
++#include <net/netfilter/nf_conntrack_seqadj.h>
++#include <net/netfilter/nf_conntrack_synproxy.h>
++#include <net/netfilter/nf_conntrack_timeout.h>
++#include <net/netfilter/nf_conntrack_timestamp.h>
++
++MODULE_AUTHOR("Brett Mastbergen <bmastbergen@untangle.com>");
++MODULE_DESCRIPTION("Livepatched conntrack dict support");
++MODULE_LICENSE("GPL");
++MODULE_INFO(livepatch, "Y");
++
++static void livepatch_destroy_conntrack(struct nf_conntrack *nfct)
++{
++	struct nf_conn *ct = (struct nf_conn *)nfct;
++	struct nf_conntrack_l4proto *l4proto;
++	void (*my_nf_ct_del_from_dying_or_unconfirmed_list)(struct nf_conn *ct);
++
++	my_nf_ct_del_from_dying_or_unconfirmed_list = (void *)kallsyms_lookup_name("nf_ct_del_from_dying_or_unconfirmed_list");
++
++	pr_debug("destroy_conntrack(%p)\n", ct);
++	NF_CT_ASSERT(atomic_read(&nfct->use) == 0);
++
++	if (unlikely(nf_ct_is_template(ct))) {
++		nf_ct_tmpl_free(ct);
++		return;
++	}
++	rcu_read_lock();
++	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
++	if (l4proto->destroy)
++		l4proto->destroy(ct);
++
++	rcu_read_unlock();
++
++	local_bh_disable();
++	/* Expectations will have been removed in clean_from_lists,
++	 * except TFTP can create an expectation on the first packet,
++	 * before connection is in the list, so we need to clean here,
++	 * too.
++	 */
++	nf_ct_remove_expectations(ct);
++
++	my_nf_ct_del_from_dying_or_unconfirmed_list(ct);
++
++	local_bh_enable();
++
++	if (ct->master)
++		nf_ct_put(ct->master);
++
++	pr_debug("destroy_conntrack: returning ct=%p to slab\n", ct);
++	destroy_dict(ct);
++	nf_conntrack_free(ct);
++}
++
++static void my_nf_ct_add_to_unconfirmed_list(struct nf_conn *ct)
++{
++	struct ct_pcpu *pcpu;
++
++	/* add this conntrack to the (per cpu) unconfirmed list */
++	ct->cpu = smp_processor_id();
++	pcpu = per_cpu_ptr(nf_ct_net(ct)->ct.pcpu_lists, ct->cpu);
++
++	spin_lock(&pcpu->lock);
++	hlist_nulls_add_head(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode,
++			     &pcpu->unconfirmed);
++	spin_unlock(&pcpu->lock);
++}
++
++static struct nf_conntrack_tuple_hash *
++livepatch_init_conntrack(struct net *net, struct nf_conn *tmpl,
++	       const struct nf_conntrack_tuple *tuple,
++	       struct nf_conntrack_l3proto *l3proto,
++	       struct nf_conntrack_l4proto *l4proto,
++	       struct sk_buff *skb,
++	       unsigned int dataoff, u32 hash)
++{
++	struct nf_conn *ct;
++	struct nf_conn_help *help;
++	struct nf_conntrack_tuple repl_tuple;
++	struct nf_conntrack_ecache *ecache;
++	struct nf_conntrack_expect *exp = NULL;
++	const struct nf_conntrack_zone *zone;
++	struct nf_conn_timeout *timeout_ext;
++	struct nf_conntrack_zone tmp;
++	unsigned int *timeouts;
++	struct nf_conn * (*__my_nf_conntrack_alloc)(struct net *net,
++		     const struct nf_conntrack_zone *zone,
++		     const struct nf_conntrack_tuple *orig,
++		     const struct nf_conntrack_tuple *repl,
++		     gfp_t gfp, u32 hash);
++
++	struct nf_conntrack_expect *
++	(*my_nf_ct_find_expectation)(struct net *net,
++		       const struct nf_conntrack_zone *zone,
++		       const struct nf_conntrack_tuple *tuple);
++
++	__my_nf_conntrack_alloc = (void *)kallsyms_lookup_name("__nf_conntrack_alloc");
++	if(!__my_nf_conntrack_alloc) {
++		BUG();
++	}
++
++	my_nf_ct_find_expectation = (void *)kallsyms_lookup_name("nf_ct_find_expectation");
++	if(!my_nf_ct_find_expectation) {
++		BUG();
++	}
++
++	if (!nf_ct_invert_tuple(&repl_tuple, tuple, l3proto, l4proto)) {
++		pr_debug("Can't invert tuple.\n");
++		return NULL;
++	}
++
++	zone = nf_ct_zone_tmpl(tmpl, skb, &tmp);
++	ct = __my_nf_conntrack_alloc(net, zone, tuple, &repl_tuple, GFP_ATOMIC,
++				  hash);
++	if (IS_ERR(ct))
++		return (struct nf_conntrack_tuple_hash *)ct;
++
++	if (!nf_ct_add_synproxy(ct, tmpl)) {
++		nf_conntrack_free(ct);
++		return ERR_PTR(-ENOMEM);
++	}
++
++	timeout_ext = tmpl ? nf_ct_timeout_find(tmpl) : NULL;
++	if (timeout_ext) {
++		timeouts = nf_ct_timeout_data(timeout_ext);
++		if (unlikely(!timeouts))
++			timeouts = l4proto->get_timeouts(net);
++	} else {
++		timeouts = l4proto->get_timeouts(net);
++	}
++
++	if (!l4proto->new(ct, skb, dataoff, timeouts)) {
++		nf_conntrack_free(ct);
++		pr_debug("can't track with proto module\n");
++		return NULL;
++	}
++
++	if (timeout_ext)
++		nf_ct_timeout_ext_add(ct, rcu_dereference(timeout_ext->timeout),
++				      GFP_ATOMIC);
++
++	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
++	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
++	nf_ct_labels_ext_add(ct);
++	nf_ct_dict_ext_add(ct);
++
++	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
++	nf_ct_ecache_ext_add(ct, ecache ? ecache->ctmask : 0,
++				 ecache ? ecache->expmask : 0,
++			     GFP_ATOMIC);
++
++	local_bh_disable();
++	if (net->ct.expect_count) {
++		spin_lock(&nf_conntrack_expect_lock);
++		exp = my_nf_ct_find_expectation(net, zone, tuple);
++		if (exp) {
++			pr_debug("expectation arrives ct=%p exp=%p\n",
++				 ct, exp);
++			/* Welcome, Mr. Bond.  We've been expecting you... */
++			__set_bit(IPS_EXPECTED_BIT, &ct->status);
++			/* exp->master safe, refcnt bumped in nf_ct_find_expectation */
++			ct->master = exp->master;
++			if (exp->helper) {
++				help = nf_ct_helper_ext_add(ct, exp->helper,
++							    GFP_ATOMIC);
++				if (help)
++					rcu_assign_pointer(help->helper, exp->helper);
++			}
++
++#ifdef CONFIG_NF_CONNTRACK_MARK
++			ct->mark = exp->master->mark;
++#endif
++#ifdef CONFIG_NF_CONNTRACK_SECMARK
++			ct->secmark = exp->master->secmark;
++#endif
++			NF_CT_STAT_INC(net, expect_new);
++		}
++		spin_unlock(&nf_conntrack_expect_lock);
++	}
++	if (!exp)
++		__nf_ct_try_assign_helper(ct, tmpl, GFP_ATOMIC);
++
++	/* Now it is inserted into the unconfirmed list, bump refcount */
++	nf_conntrack_get(&ct->ct_general);
++	my_nf_ct_add_to_unconfirmed_list(ct);
++
++	local_bh_enable();
++
++	if (exp) {
++		if (exp->expectfn)
++			exp->expectfn(ct, exp);
++		nf_ct_expect_put(exp);
++	}
++
++	new_dict(ct);
++
++	return &ct->tuplehash[IP_CT_DIR_ORIGINAL];
++}
++
++
++static struct klp_func funcs[] = {
++	{
++		.old_name = "init_conntrack",
++		.new_func = livepatch_init_conntrack,
++	},
++	{
++		.old_name = "destroy_conntrack",
++		.new_func = livepatch_destroy_conntrack,
++	}, { }
++};
++
++static struct klp_object objs[] = {
++	{
++		/* name being NULL means vmlinux */
++		.funcs = funcs,
++	}, { }
++};
++
++static struct klp_patch patch = {
++	.mod = THIS_MODULE,
++	.objs = objs,
++};
++
++static void nf_conntrack_dict_livepatch_exit(void)
++{
++	WARN_ON(klp_disable_patch(&patch));
++	WARN_ON(klp_unregister_patch(&patch));
++	nf_conntrack_dict_disable();
++}
++
++static int nf_conntrack_dict_livepatch_init(void)
++{
++	int err = 0;
++
++	err = nf_conntrack_dict_enable();
++	if (err) {
++		goto err;
++	}
++
++	err = klp_register_patch(&patch);
++	if (err) {
++		goto err_conntrack_dict_disable;
++	}
++
++	err = klp_enable_patch(&patch);
++	if (err) {
++		goto err_unregister_patch;
++	}
++
++	return 0;
++
++err_unregister_patch:
++	WARN_ON(klp_unregister_patch(&patch));
++err_conntrack_dict_disable:
++	nf_conntrack_dict_disable();
++err:
++	return err;
++}
++
++module_init(nf_conntrack_dict_livepatch_init);
++module_exit(nf_conntrack_dict_livepatch_exit);
+diff --git a/net/netfilter/nft_dict.c b/net/netfilter/nft_dict.c
+new file mode 100644
+index 000000000000..25a419a23843
+--- /dev/null
++++ b/net/netfilter/nft_dict.c
+@@ -0,0 +1,165 @@
++#include <linux/glob.h>
++#include <linux/tcp.h>
++#include <net/netfilter/nf_tables.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_dict.h>
++
++#define DICT_FIELD_SIZE 128
++#define DICT_VALUE_SIZE 128
++struct nft_dict {
++	char field[DICT_FIELD_SIZE];
++	u8 field_len;
++	u32 field_hash;
++	char value[DICT_VALUE_SIZE];
++	u8 value_len;
++	u32 value_hash;
++	u32 set;
++};
++
++static const struct nla_policy nft_dict_policy[NFTA_DICT_MAX + 1] = {
++	[NFTA_DICT_FIELD]	= { .type = NLA_STRING, .len = DICT_FIELD_SIZE },
++	[NFTA_DICT_VALUE]	= { .type = NLA_STRING, .len = DICT_VALUE_SIZE },
++	[NFTA_DICT_SET]		= { .type = NLA_U32 },
++};
++
++static void nft_dict_get_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt)
++{
++	struct nft_dict *priv = nft_expr_priv(expr);
++	enum ip_conntrack_info ctinfo;
++	struct nf_conn *ct;
++	struct nf_conn_dict * dict;
++	struct nf_conn_dict_pair * pair;
++
++	regs->verdict.code = NFT_BREAK;
++	
++	ct = nf_ct_get(pkt->skb, &ctinfo);
++	if (ct == NULL ) {
++		return;
++	}
++
++	dict = find_conntrack_dict(ct);
++	if(!dict) {
++		return;
++	}
++
++	pair = find_conntrack_dict_pair(dict, &priv->field_hash);
++	if(!pair) {
++		return;
++	}
++
++	rcu_read_lock();
++	if(priv->value_hash != pair->value->hash) {
++		if(glob_match(priv->value, pair->value->str)) {
++			regs->verdict.code = NFT_CONTINUE;
++		}
++	} else {
++		regs->verdict.code = NFT_CONTINUE;
++	}
++
++	rcu_read_unlock();
++}
++
++static void nft_dict_set_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt)
++{
++	struct nft_dict *priv = nft_expr_priv(expr);
++	enum ip_conntrack_info ctinfo;
++	struct nf_conn *ct;
++	struct nf_conn_dict * dict;
++
++	ct = nf_ct_get(pkt->skb, &ctinfo);
++	if (ct == NULL) {
++		return;
++	}
++
++	dict = find_conntrack_dict(ct);
++	if(!dict) {
++		return;
++	}
++
++	new_dict_pair(dict, priv->field, priv->value);
++}
++
++static int nft_dict_init(const struct nft_ctx *ctx, const struct nft_expr *expr, const struct nlattr * const tb[])
++{
++	struct nft_dict *priv = nft_expr_priv(expr);
++	if (tb[NFTA_DICT_FIELD] == NULL || tb[NFTA_DICT_VALUE] == NULL)
++		return -EINVAL;
++
++	nla_strlcpy(priv->field, tb[NFTA_DICT_FIELD], DICT_FIELD_SIZE);
++	priv->field_len = strlen(priv->field);
++	priv->field_hash = jhash(priv->field, priv->field_len, 0);
++	nla_strlcpy(priv->value, tb[NFTA_DICT_VALUE], DICT_VALUE_SIZE);
++	priv->value_len = strlen(priv->value);
++	priv->value_hash = jhash(priv->value, priv->value_len, 0);
++
++	return 0;
++}
++
++static int nft_dict_dump(struct sk_buff *skb, const struct nft_expr *expr)
++{
++	const struct nft_dict *priv = nft_expr_priv(expr);
++
++	if(nla_put_string(skb, NFTA_DICT_FIELD, priv->field))
++		return -1;
++
++	if(nla_put_string(skb, NFTA_DICT_VALUE, priv->value))
++		return -1;
++
++	if(nla_put_be32(skb, NFTA_DICT_SET, htonl(priv->set)))
++		return -1;
++
++	return 0;
++}
++
++static struct nft_expr_type nft_dict_type;
++static const struct nft_expr_ops nft_dict_get_ops = {
++	.eval = nft_dict_get_eval,
++	.size = NFT_EXPR_SIZE(sizeof(struct nft_dict)),
++	.init = nft_dict_init,
++	.dump = nft_dict_dump,
++	.type = &nft_dict_type,
++};
++
++static const struct nft_expr_ops nft_dict_set_ops = {
++	.eval = nft_dict_set_eval,
++	.size = NFT_EXPR_SIZE(sizeof(struct nft_dict)),
++	.init = nft_dict_init,
++	.dump = nft_dict_dump,
++	.type = &nft_dict_type,
++};
++
++static const struct nft_expr_ops *
++nft_dict_select_ops(const struct nft_ctx *ctx,
++		    const struct nlattr * const tb[])
++{
++	if (tb[NFTA_DICT_SET]) {
++		return &nft_dict_set_ops;
++	}
++
++	return &nft_dict_get_ops;
++}
++
++static struct nft_expr_type nft_dict_type __read_mostly = {
++	.name = "dict",
++	.select_ops = &nft_dict_select_ops,
++	.owner = THIS_MODULE,
++	.policy = nft_dict_policy,
++	.maxattr = NFTA_DICT_MAX,
++};
++
++static int __init nft_dict_module_init(void)
++{
++	return nft_register_expr(&nft_dict_type);
++};
++
++static void __exit nft_dict_module_exit(void)
++{
++	nft_unregister_expr(&nft_dict_type);
++}
++
++module_init(nft_dict_module_init);
++module_exit(nft_dict_module_exit);
++
++MODULE_AUTHOR("Brett Mastbergen");
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("Generic field/value pair matching for conntrack");
+diff --git a/net/netfilter/xt_conndict.c b/net/netfilter/xt_conndict.c
+new file mode 100644
+index 000000000000..53ba7f44ea84
+--- /dev/null
++++ b/net/netfilter/xt_conndict.c
+@@ -0,0 +1,103 @@
++#include <linux/module.h>
++#include <linux/glob.h>
++#include <linux/netfilter/x_tables.h>
++#include <linux/netfilter/xt_conndict.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_dict.h>
++
++MODULE_AUTHOR("Brett Mastbergen <bmastbergen@untangle.com>");
++MODULE_DESCRIPTION("Just a skeleton");
++MODULE_LICENSE("GPL");
++
++static bool dict_mt(const struct sk_buff *skb, struct xt_action_param *par)
++{
++	struct xt_dict_info *info = (struct xt_dict_info *)par->matchinfo;
++	enum ip_conntrack_info ctinfo;
++	struct nf_conn *ct;
++	struct nf_conn_dict * dict;
++	bool invert = info->flags & XT_CONNDICT_FLAG_INVERT;
++
++	ct = nf_ct_get(skb, &ctinfo);
++	if (ct == NULL) {
++		return invert;
++	}
++
++	dict = find_conntrack_dict(ct);
++	if(!dict) {
++		return invert;
++	}
++
++	if(info->flags & XT_CONNDICT_FLAG_SET) {
++		new_dict_pair(dict, info->field, info->value);
++
++		return !invert;
++	} else {
++		struct nf_conn_dict_pair * pair;
++
++		pair = find_conntrack_dict_pair(dict, &info->field_hash);
++		if(!pair) {
++			return invert;
++		}
++
++		rcu_read_lock();
++		if(info->value_hash != pair->value->hash) {
++			if(glob_match(info->value, pair->value->str)) {
++				rcu_read_unlock();
++				return !invert;
++			}
++		} else {
++			return !invert;
++		}
++
++		rcu_read_unlock();
++	}
++
++	return invert;
++}
++
++static int dict_mt_check(const struct xt_mtchk_param *par)
++{
++	struct xt_dict_info *info = (struct xt_dict_info *)par->matchinfo;
++
++	if(!(info->flags & XT_CONNDICT_FLAG_SET)) {
++		info->field_hash = jhash(info->field, info->field_len, 0);
++		info->value_hash = jhash(info->value, info->value_len, 0);
++	}
++
++	return 0;
++}
++
++static void dict_mt_destroy(const struct xt_mtdtor_param *par)
++{
++}
++
++static struct xt_match xt_dict_mt_reg __read_mostly = {
++	.name       = "conndict",
++	.revision   = 0,
++	.family     = NFPROTO_UNSPEC,
++	.checkentry = dict_mt_check,
++	.match      = dict_mt,
++	.destroy    = dict_mt_destroy,
++	.matchsize  = sizeof(struct xt_dict_info),
++	.me         = THIS_MODULE,
++};
++
++static void __exit xt_dict_exit(void)
++{
++	xt_unregister_match(&xt_dict_mt_reg);
++}
++
++static int __init xt_dict_init(void)
++{
++	int err = 0;
++
++	err = xt_register_match(&xt_dict_mt_reg);
++	if(err < 0) {
++		pr_err("%s: Unable to register match: %d\n", __func__, err);
++	}
++
++	return err;
++}
++
++module_init(xt_dict_init);
++module_exit(xt_dict_exit);
+-- 
+2.11.0
+
-- 
2.11.0

